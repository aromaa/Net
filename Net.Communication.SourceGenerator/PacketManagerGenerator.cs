using System.CodeDom.Compiler;
using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Net.Communication.SourceGenerator;

[Generator(LanguageNames.CSharp)]
public sealed class PacketManagerGenerator : IIncrementalGenerator
{
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		IncrementalValuesProvider<(INamedTypeSymbol Type, ImmutableArray<INamedTypeSymbol> Managers)> registrations = context.SyntaxProvider.ForAttributeWithMetadataName("Net.Communication.Attributes.PacketManagerRegisterAttribute",
			static (node, _) => node is ClassDeclarationSyntax,
			static (context, _) =>
			{
				ImmutableArray<INamedTypeSymbol>.Builder builder = ImmutableArray.CreateBuilder<INamedTypeSymbol>(context.Attributes.Length);
				foreach (AttributeData attributeData in context.Attributes)
				{
					if (attributeData.ConstructorArguments.IsDefaultOrEmpty || attributeData.ConstructorArguments[0].Value is not INamedTypeSymbol namedType)
					{
						continue;
					}

					builder.Add(namedType);
				}

				return ((INamedTypeSymbol)context.TargetSymbol, builder.ToImmutable());
			});

		IncrementalValuesProvider<(SemanticModel SemanticModel, MethodDeclarationSyntax GeneratorMethod, INamedTypeSymbol? Manager)> generators = context.SyntaxProvider.ForAttributeWithMetadataName("Net.Communication.Attributes.PacketManagerGeneratorAttribute",
			static (node, _) => node is MethodDeclarationSyntax,
			static (context, _) => (context.SemanticModel, (MethodDeclarationSyntax)context.TargetNode, context.Attributes[0].ConstructorArguments[0].Value as INamedTypeSymbol));

		registrations.Combine(generators.Collect());

		context.RegisterImplementationSourceOutput(generators.Combine(registrations.Collect()), static (sourceProductionContext, value) =>
		{
			(SemanticModel semanticModel, MethodDeclarationSyntax generatorMethod, INamedTypeSymbol? manager) = value.Left;
			if (manager is null)
			{
				return;
			}

			INamedTypeSymbol? parserType = semanticModel.Compilation.GetTypeByMetadataName("Net.Communication.Incoming.Parser.IIncomingPacketParser");
			INamedTypeSymbol? parserGenericType = semanticModel.Compilation.GetTypeByMetadataName("Net.Communication.Incoming.Parser.IIncomingPacketParser`1");
			INamedTypeSymbol? handlerType = semanticModel.Compilation.GetTypeByMetadataName("Net.Communication.Incoming.Handler.IIncomingPacketHandler");
			INamedTypeSymbol? handlerGenericType = semanticModel.Compilation.GetTypeByMetadataName("Net.Communication.Incoming.Handler.IIncomingPacketHandler`1");
			INamedTypeSymbol? composerType = semanticModel.Compilation.GetTypeByMetadataName("Net.Communication.Outgoing.IOutgoingPacketComposer");
			INamedTypeSymbol? composerGenericType = semanticModel.Compilation.GetTypeByMetadataName("Net.Communication.Outgoing.IOutgoingPacketComposer`1");

			INamedTypeSymbol? parserIdType = semanticModel.Compilation.GetTypeByMetadataName("Net.Communication.Attributes.PacketParserIdAttribute");
			INamedTypeSymbol? composerIdType = semanticModel.Compilation.GetTypeByMetadataName("Net.Communication.Attributes.PacketComposerIdAttribute");

			StringBuilder hintNameBuilder = new();

			using StringWriter stream = new();
			using (IndentedTextWriter writer = new(stream, "\t"))
			{
				writer.WriteLine("// <auto-generated/>");
				writer.WriteLine("#pragma warning disable");
				writer.WriteLine();

				List<ClassDeclarationSyntax> hierarchy = [];
				BaseNamespaceDeclarationSyntax? namespaceDeclaration = null;
				for (SyntaxNode? node = generatorMethod; node is not null; node = node.Parent)
				{
					if (node is ClassDeclarationSyntax classDeclaration)
					{
						hierarchy.Add(classDeclaration);
					}
					else if (node is BaseNamespaceDeclarationSyntax syntax)
					{
						namespaceDeclaration = syntax;

						break;
					}
					else if (node is CompilationUnitSyntax)
					{
						break;
					}
				}

				if (namespaceDeclaration is not null)
				{
					hintNameBuilder.Append(namespaceDeclaration.Name.ToString().Replace('.', '_'));
					hintNameBuilder.Append('_');

					writer.WriteLine($"namespace {namespaceDeclaration.Name}");
					writer.WriteLine("{");
					writer.Indent++;
				}

				for (int j = hierarchy.Count - 1; j >= 0; j--)
				{
					ClassDeclarationSyntax classDeclaration = hierarchy[j];

					hintNameBuilder.Append(classDeclaration.Identifier);
					hintNameBuilder.Append('_');

					if (classDeclaration.Arity > 0)
					{
						hintNameBuilder.Append(classDeclaration.Arity);
						hintNameBuilder.Append('_');
					}

					writer.WriteLine($"partial class {classDeclaration.Identifier.ToString() + classDeclaration.TypeParameterList}");
					writer.WriteLine("{");
					writer.Indent++;
				}

				string returnType = $"global::Net.Communication.Manager.{generatorMethod.ReturnType}";

				bool full = generatorMethod.ReturnType is GenericNameSyntax;

				writer.WriteLine($"{generatorMethod.Modifiers} {returnType} {generatorMethod.Identifier}({generatorMethod.ParameterList.Parameters})");
				writer.WriteLine("{");
				writer.Indent++;
				writer.WriteLine($"global::System.Collections.Immutable.ImmutableArray<{returnType}.HandlerData>.Builder handlers = global::System.Collections.Immutable.ImmutableArray.CreateBuilder<{returnType}.HandlerData>();");
				writer.WriteLine($"global::System.Collections.Immutable.ImmutableArray<{returnType}.ComposerHandlerCandidateData>.Builder composerHandleCandidates = global::System.Collections.Immutable.ImmutableArray.CreateBuilder<{returnType}.ComposerHandlerCandidateData>();");
				if (full)
				{
					writer.WriteLine($"global::System.Collections.Immutable.ImmutableArray<{returnType}.ParserData>.Builder parsers = global::System.Collections.Immutable.ImmutableArray.CreateBuilder<{returnType}.ParserData>();");
					writer.WriteLine($"global::System.Collections.Immutable.ImmutableArray<{returnType}.ComposerData>.Builder composers = global::System.Collections.Immutable.ImmutableArray.CreateBuilder<{returnType}.ComposerData>();");
				}

				List<(INamedTypeSymbol Type, string ComposerId, ITypeSymbol? PacketType)> composers = [];
				Dictionary<INamedTypeSymbol, (ITypeSymbol HandlerType, INamedTypeSymbol InterfaceType)> composerHandlerCandidates = [];
				foreach ((INamedTypeSymbol type, ImmutableArray<INamedTypeSymbol> managers) in value.Right)
				{
					if (!managers.Contains(manager))
					{
						continue;
					}

					bool handler = false;
					string? parserId = null;
					string? composerId = null;
					ITypeSymbol? parserHandlesType = null;
					ITypeSymbol? handlerHandlesType = null;
					ITypeSymbol? composerHandlesType = null;
					foreach (INamedTypeSymbol implementedInterface in type.AllInterfaces)
					{
						if (implementedInterface.IsGenericType)
						{
							if (SymbolEqualityComparer.Default.Equals(implementedInterface.ConstructedFrom, parserGenericType))
							{
								if (full)
								{
									parserHandlesType = GetHandledType(implementedInterface.TypeArguments[0]);
								}
							}
							else if (SymbolEqualityComparer.Default.Equals(implementedInterface.ConstructedFrom, handlerGenericType))
							{
								handler = true;
								handlerHandlesType = GetHandledType(implementedInterface.TypeArguments[0]);
							}
							else if (SymbolEqualityComparer.Default.Equals(implementedInterface.ConstructedFrom, composerGenericType))
							{
								if (full)
								{
									composerHandlesType = GetHandledType(implementedInterface.TypeArguments[0]);
								}
							}
							else
							{
								composerHandlerCandidates.Add(implementedInterface.OriginalDefinition, (type, implementedInterface));
							}

							static ITypeSymbol? GetHandledType(ITypeSymbol symbol)
							{
								if (symbol is ITypeParameterSymbol typeParameter)
								{
									if (typeParameter.ConstraintTypes.Length == 1)
									{
										return typeParameter.ConstraintTypes[0];
									}

									return null;
								}

								return symbol;
							}

							continue;
						}

						if (full && SymbolEqualityComparer.Default.Equals(implementedInterface, parserType))
						{
							foreach (AttributeData attributeData in type.GetAttributes())
							{
								if (SymbolEqualityComparer.Default.Equals(attributeData.AttributeClass, parserIdType))
								{
									parserId = attributeData.ConstructorArguments[0].ToCSharpString();

									break;
								}
							}
						}
						else if (SymbolEqualityComparer.Default.Equals(implementedInterface, handlerType))
						{
							handler = true;
						}
						else if (full && SymbolEqualityComparer.Default.Equals(implementedInterface, composerType))
						{
							foreach (AttributeData attributeData in type.GetAttributes())
							{
								if (SymbolEqualityComparer.Default.Equals(attributeData.AttributeClass, composerIdType))
								{
									composerId = attributeData.ConstructorArguments[0].ToCSharpString();

									break;
								}
							}
						}
					}

					if (parserId is not null)
					{
						writer.WriteLine($"parsers.Add(new {returnType}.ParserData(typeof({(type.IsGenericType ? type.ConstructUnboundGenericType() : type)}), {parserId}, {(parserHandlesType is not null ? $"typeof({parserHandlesType})" : "null")}));");
					}

					if (handler)
					{
						writer.WriteLine($"handlers.Add(new {returnType}.HandlerData(typeof({(type.IsGenericType ? type.ConstructUnboundGenericType() : type)}), {(handlerHandlesType is not null ? $"typeof({handlerHandlesType})" : "null")}));");
					}

					if (composerId is not null)
					{
						composers.Add((type, composerId, composerHandlesType));
					}
				}

				foreach ((INamedTypeSymbol Type, string ComposerId, ITypeSymbol? PacketType) composer in composers)
				{
					INamedTypeSymbol type = composer.Type;
					ITypeSymbol? packetType = composer.PacketType;
					if (composer.Type.IsGenericType)
					{
						ITypeSymbol[] composerGenericArguments = type.TypeArguments.ToArray();
						ITypeSymbol[]? packetGenericArguments = (packetType as INamedTypeSymbol)?.TypeArguments.ToArray();
						foreach (ITypeSymbol composerTypeArgument in type.TypeArguments)
						{
							if (composerTypeArgument is ITypeParameterSymbol typeParameter)
							{
								foreach (ITypeSymbol? constraintType in typeParameter.ConstraintTypes)
								{
									if (constraintType is not INamedTypeSymbol { OriginalDefinition: { } originalDefinition } constraintSymbol ||
										!composerHandlerCandidates.TryGetValue(originalDefinition, out (ITypeSymbol HandlerType, INamedTypeSymbol InterfaceType) candidateType))
									{
										continue;
									}

									Dictionary<ITypeSymbol, ITypeSymbol> replacements = [];
									replacements[composerTypeArgument] = candidateType.HandlerType;

									ImmutableArray<ITypeSymbol> targetGenericArguments = constraintSymbol.TypeArguments;
									ImmutableArray<ITypeSymbol> candidateGenericArguments = candidateType.InterfaceType.TypeArguments;

									for (int i = 0; i < targetGenericArguments.Length; i++)
									{
										replacements[targetGenericArguments[i]] = candidateGenericArguments[i];
									}

									for (int i = 0; i < composerGenericArguments.Length; i++)
									{
										if (!replacements.TryGetValue(composerGenericArguments[i], out ITypeSymbol replacementType))
										{
											continue;
										}

										composerGenericArguments[i] = replacementType;
									}

									if (packetGenericArguments is not null)
									{
										for (int i = 0; i < packetGenericArguments.Length; i++)
										{
											if (!replacements.TryGetValue(packetGenericArguments[i], out ITypeSymbol replacementType))
											{
												continue;
											}

											packetGenericArguments[i] = replacementType;
										}
									}
								}
							}
						}

						type = composerGenericArguments.Any(s => s is ITypeParameterSymbol)
							? type.ConstructUnboundGenericType()
							: type.OriginalDefinition.Construct(composerGenericArguments);

						if (packetGenericArguments is { Length: > 0 })
						{
							packetType = packetGenericArguments.Any(s => s is ITypeParameterSymbol)
								? ((INamedTypeSymbol)packetType!).ConstructUnboundGenericType()
								: ((INamedTypeSymbol)packetType!).OriginalDefinition.Construct(packetGenericArguments);
						}
					}

					writer.WriteLine($"composers.Add(new {returnType}.ComposerData(typeof({type}), {composer.ComposerId}, {(packetType is not null ? $"typeof({packetType})" : "null")}));");
				}

				foreach (KeyValuePair<INamedTypeSymbol, (ITypeSymbol HandlerType, INamedTypeSymbol InterfaceType)> entry in composerHandlerCandidates)
				{
					writer.WriteLine($"composerHandleCandidates.Add(new {returnType}.ComposerHandlerCandidateData(typeof({entry.Key.ConstructUnboundGenericType()}), typeof({entry.Value.HandlerType}), typeof({entry.Value.InterfaceType})));");
				}

				if (full)
				{
					writer.WriteLine($"return new {returnType}(parsers.ToImmutable(), handlers.ToImmutable(), composers.ToImmutable(), composerHandleCandidates.ToImmutable());");
				}
				else
				{
					writer.WriteLine($"return new {returnType}(handlers.ToImmutable(), composerHandleCandidates.ToImmutable());");
				}

				writer.Indent--;
				writer.WriteLine("}");

				for (int j = namespaceDeclaration is not null ? -1 : 0; j < hierarchy.Count; j++)
				{
					writer.Indent--;
					writer.WriteLine("}");
				}
			}

			hintNameBuilder.Append(generatorMethod.Identifier);
			hintNameBuilder.Append(".g.cs");

			string hintName = hintNameBuilder.ToString();
			string source = stream.ToString();

			sourceProductionContext.AddSource(hintName, source);
		});
	}
}
